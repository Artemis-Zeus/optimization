<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-06-10T01:07:29.1840596"><title>Set集合详解QA | 技术知识库</title><script type="application/json" id="virtual-toc-data">[{"id":"z9muka7_4","level":0,"title":"📋 知识结构","anchor":"#z9muka7_4"},{"id":"hashset","level":0,"title":"🔍 HashSet深入分析","anchor":"#hashset"},{"id":"z9muka7_6","level":0,"title":"💡 面试技巧","anchor":"#z9muka7_6"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Set集合详解QA | 技术知识库"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="技术知识库 Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/set集合详解qa.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Set集合详解QA | 技术知识库"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/set集合详解qa.html#webpage",
    "url": "writerside-documentation/set集合详解qa.html",
    "name": "Set集合详解QA | 技术知识库",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "技术知识库 Help"
}</script><!-- End Schema.org --></head><body data-id="Set集合详解QA" data-main-title="Set集合详解QA" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Java集合面试大纲.md|Java集合面试大纲"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>技术知识库  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Set集合详解QA" id="Set集合详解QA.md">Set集合详解QA</h1><p id="z9muka7_3">Set接口定义了不重复元素的集合。本文档深入分析HashSet、TreeSet、LinkedHashSet等主要实现类的去重原理、数据结构和性能特点。</p><section class="chapter"><h2 id="z9muka7_4" data-toc="z9muka7_4">📋 知识结构</h2><svg aria-roledescription="mindmap" role="graphics-document document" viewBox="5 5 771.2353515625 433.75579833984375" style="max-width: 771.2353515625px;" xmlns="http://www.w3.org/2000/svg" width="100%" id="mermaid"><g></g><g class="mindmap-edges"><path class="edge section-edge-0 edge-depth-1" d="M 442.17892736242584,112.18572730620693 L 429.97336707117745,80.0540644426824 L417.76780677992906,47.92240157915788"></path><path class="edge section-edge-0 edge-depth-1" d="M 460.16342502052845,118.15973500869288 L 502.42061598025543,91.29101770834868 L544.6778069399825,64.42230040800447"></path><path class="edge section-edge-0 edge-depth-1" d="M 462.40420004915035,127.94835740354289 L 509.33047053008397,133.42953167014494 L556.2567410110175,138.910705936747"></path><path class="edge section-edge-0 edge-depth-1" d="M 432.9947052198856,122.40850160016228 L 383.4485470319157,109.43491289677351 L333.90238884394586,96.46132419338474"></path><path class="edge section-edge-0 edge-depth-0" d="M 393.2040654678673,202.92128113310943 L 416.0216164296428,170.6862831920122 L438.8391673914183,138.451285250915"></path><path class="edge section-edge-1 edge-depth-1" d="M 318.6607988771353,323.93042411320647 L 279.39214878639433,351.21781413018823 L240.12349869565338,378.50520414717"></path><path class="edge section-edge-1 edge-depth-1" d="M 315.9788037601519,315.3423530752064 L 257.1292647526049,315.2308053254246 L198.27972574505793,315.11925757564285"></path><path class="edge section-edge-1 edge-depth-1" d="M 334.27342037212713,330.00449019014206 L 341.6149921433482,362.61329721110724 L348.9565639145693,395.2221042320724"></path><path class="edge section-edge-1 edge-depth-1" d="M 344.5523840425954,321.75492068535453 L 396.8537957150603,346.3540781753345 L449.1552073875252,370.9532356653145"></path><path class="edge section-edge-1 edge-depth-0" d="M 377.46704393463983,228.39339044424742 L 357.7582605678808,265.26761131367823 L338.0494772011218,302.14183218310905"></path><path class="edge section-edge-2 edge-depth-1" d="M 562.2157866552216,242.8326329715464 L 577.1715224746997,273.0002530652263 L592.1272582941779,303.1678731589061"></path><path class="edge section-edge-2 edge-depth-1" d="M 569.5402422371471,223.97458058672973 L 631.6052317488602,199.9290709698005 L693.6702212605733,175.88356135287128"></path><path class="edge section-edge-2 edge-depth-1" d="M 570.2675478847272,232.3072226748444 L 637.3181645687063,245.58467534452785 L704.3687812526854,258.8621280142113"></path><path class="edge section-edge-2 edge-depth-1" d="M 542.4810867997908,236.7499844640667 L 501.48115103272187,259.8231221553657 L460.4812152656529,282.89625984666463"></path><path class="edge section-edge-2 edge-depth-0" d="M 399.4860915250887,216.40818823197733 L 470.0455048727289,222.27895915397195 L540.6049182203691,228.14973007596657"></path><path class="edge section-edge-3 edge-depth-1" d="M 239.70519332057708,178.29758874372598 L 245.2706627637043,206.38953533614514 L250.83613220683154,234.4814819285643"></path><path class="edge section-edge-3 edge-depth-1" d="M 221.98306957420624,161.1853228902336 L 155.9966167170934,150.4977051519654 L90.01016385998054,139.81008741369718"></path><path class="edge section-edge-3 edge-depth-1" d="M 227.8911107411768,151.50848057268666 L 205.54197475566838,121.18283309981061 L183.19283877015997,90.85718562693454"></path><path class="edge section-edge-3 edge-depth-1" d="M 223.07076634522684,169.64819533561501 L 167.97347479187943,194.0039043601543 L112.87618323853201,218.35961338469366"></path><path class="edge section-edge-3 edge-depth-0" d="M 370.37596397275655,210.22035241155032 L 310.66392637793814,189.37400489595038 L250.95188878311973,168.52765738035043"></path></g><g class="mindmap-nodes"><g transform="translate(346.60693148599614, 196.26443749865962)" class="mindmap-node section--1 section-root"><g transform="translate(37.93081283569336, 18.9)"><circle r="37.93081283569336" class="node-bkg node-circle" id="node-0"></circle></g><g transform="translate(37.93081283569336, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">Set集合</tspan></tspan></text></g></g></g><g transform="translate(408.6756736267074, 107.3081288853648)" class="mindmap-node section-0"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h67.65962982177734 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-1"></path><line y2="37.8" x2="77.65962982177734" y1="37.8" x1="0" class="node-line-0"></line></g><g transform="translate(38.82981491088867, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">HashSet</tspan></tspan></text></g></g></g><g transform="translate(293.0942744031835, 296.4707851286969)" class="mindmap-node section-1"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h65.76900482177734 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-6"></path><line y2="37.8" x2="75.76900482177734" y1="37.8" x1="0" class="node-line-1"></line></g><g transform="translate(37.88450241088867, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">TreeSet</tspan></tspan></text></g></g></g><g transform="translate(493.09285053729366, 210.49348080928428)" class="mindmap-node section-2"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h114.92082977294922 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-11"></path><line y2="37.8" x2="124.92082977294922" y1="37.8" x1="0" class="node-line-2"></line></g><g transform="translate(62.46041488647461, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">LinkedHashSet</tspan></tspan></text></g></g></g><g transform="translate(194.25410913609107, 144.68357229324113)" class="mindmap-node section-3"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h75.0719985961914 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-16"></path><line y2="37.8" x2="85.0719985961914" y1="37.8" x1="0" class="node-line-3"></line></g><g transform="translate(42.5359992980957, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">去重原理</tspan></tspan></text></g></g></g><g transform="translate(354.41945986867483, 15)" class="mindmap-node section-0"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h106.04357147216797 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-2"></path><line y2="37.8" x2="116.04357147216797" y1="37.8" x1="0" class="node-line-0"></line></g><g transform="translate(58.021785736083984, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">基于HashMap</tspan></tspan></text></g></g></g><g transform="translate(507.2732434229148, 37.473906531332545)" class="mindmap-node section-0"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h90.125 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-3"></path><line y2="37.8" x2="100.125" y1="37.8" x1="0" class="node-line-0"></line></g><g transform="translate(50.0625, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">哈希表实现</tspan></tspan></text></g></g></g><g transform="translate(536.6314523547252, 121.75093445492507)" class="mindmap-node section-0"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h59.04800033569336 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-4"></path><line y2="37.8" x2="69.04800033569336" y1="37.8" x1="0" class="node-line-0"></line></g><g transform="translate(34.52400016784668, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">无序性</tspan></tspan></text></g></g></g><g transform="translate(276.85560622813966, 73.76169690818222)" class="mindmap-node section-0"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h75.0719985961914 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-5"></path><line y2="37.8" x2="85.0719985961914" y1="37.8" x1="0" class="node-line-0"></line></g><g transform="translate(42.5359992980957, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">去重快速</tspan></tspan></text></g></g></g><g transform="translate(171.22904752263253, 368.1648431316796)" class="mindmap-node section-1"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h103.15294647216797 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-7"></path><line y2="37.8" x2="113.15294647216797" y1="37.8" x1="0" class="node-line-1"></line></g><g transform="translate(56.576473236083984, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">基于TreeMap</tspan></tspan></text></g></g></g><g transform="translate(133.21725269113767, 296.1908255221524)" class="mindmap-node section-1"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h90.125 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-8"></path><line y2="37.8" x2="100.125" y1="37.8" x1="0" class="node-line-1"></line></g><g transform="translate(50.0625, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">红黑树实现</tspan></tspan></text></g></g></g><g transform="translate(317.2272073047776, 390.95580929351763)" class="mindmap-node section-1"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h60.04800033569336 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-9"></path><line y2="37.8" x2="70.04800033569336" y1="37.8" x1="0" class="node-line-1"></line></g><g transform="translate(35.02400016784668, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">有序性</tspan></tspan></text></g></g></g><g transform="translate(420.67412711604845, 358.43737122197217)" class="mindmap-node section-1"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h74.109375 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-10"></path><line y2="37.8" x2="84.109375" y1="37.8" x1="0" class="node-line-1"></line></g><g transform="translate(42.0546875, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">自动排序</tspan></tspan></text></g></g></g><g transform="translate(543.4359625395472, 297.7070253211682)" class="mindmap-node section-2"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h100.70763397216797 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-12"></path><line y2="37.8" x2="110.70763397216797" y1="37.8" x1="0" class="node-line-2"></line></g><g transform="translate(55.353816986083984, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">继承HashSet</tspan></tspan></text></g></g></g><g transform="translate(649.0790730739521, 151.56466113031672)" class="mindmap-node section-2"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h107.15625 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-13"></path><line y2="37.8" x2="117.15625" y1="37.8" x1="0" class="node-line-2"></line></g><g transform="translate(58.578125, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">维护插入顺序</tspan></tspan></text></g></g></g><g transform="translate(676.0470644155486, 242.87586987977144)" class="mindmap-node section-2"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h76.0719985961914 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-14"></path><line y2="37.8" x2="86.0719985961914" y1="37.8" x1="0" class="node-line-2"></line></g><g transform="translate(43.0359992980957, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">双向链表</tspan></tspan></text></g></g></g><g transform="translate(404.37303734357977, 271.35276350144704)" class="mindmap-node section-2"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h76.0719985961914 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-15"></path><line y2="37.8" x2="86.0719985961914" y1="37.8" x1="0" class="node-line-2"></line></g><g transform="translate(43.0359992980957, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">性能均衡</tspan></tspan></text></g></g></g><g transform="translate(204.65746709322184, 230.29549837904915)" class="mindmap-node section-3"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h88.1875 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-17"></path><line y2="37.8" x2="98.1875" y1="37.8" x1="0" class="node-line-3"></line></g><g transform="translate(49.09375, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">equals方法</tspan></tspan></text></g></g></g><g transform="translate(15, 118.51183801068964)" class="mindmap-node section-3"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h110.40625 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-18"></path><line y2="37.8" x2="120.40625" y1="37.8" x1="0" class="node-line-3"></line></g><g transform="translate(60.203125, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">hashCode方法</tspan></tspan></text></g></g></g><g transform="translate(105.27821607714998, 59.882093906380085)" class="mindmap-node section-3"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h128.03125 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-19"></path><line y2="37.8" x2="138.03125" y1="37.8" x1="0" class="node-line-3"></line></g><g transform="translate(69.015625, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">Comparable接口</tspan></tspan></text></g></g></g><g transform="translate(48.108840813878714, 205.52423642706754)" class="mindmap-node section-3"><g><path d="M0 32.8 v-27.799999999999997 q0,-5 5,-5 h92.09600067138672 q5,0 5,5 v32.8 H0 Z" class="node-bkg node-no-border" id="node-20"></path><line y2="37.8" x2="102.09600067138672" y1="37.8" x1="0" class="node-line-3"></line></g><g transform="translate(51.04800033569336, 5)" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" dy="1em"><g><rect style="stroke: none" class="background"></rect><text style="" y="-10.1"><tspan dy="1.1em" y="-0.1em" x="0" class="text-outer-tspan"><tspan font-weight="normal" class="text-inner-tspan" font-style="normal">对象相等性</tspan></tspan></text></g></g></g></g></svg></section><section class="chapter"><h2 id="hashset" data-toc="hashset">🔍 HashSet深入分析</h2><section class="chapter"><h3 id="q1-hashset" data-toc="q1-hashset">Q1: HashSet的底层实现原理是什么？是如何保证元素不重复的？</h3><p id="z9muka7_10"><span class="control" id="z9muka7_15">答案：</span></p><p id="z9muka7_11"><span class="control" id="z9muka7_16">HashSet结构示意：</span></p><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 2355.078125 360"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="2355.078125" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(0, 48.51171875)" class="root"><g class="clusters"><g data-look="classic" id="去重机制" class="cluster"><rect height="246.9765625" width="1333.390625" y="8" x="8" style=""></rect><g transform="translate(642.640625, 8)" class="cluster-label"><foreignObject height="24" width="64.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>去重机制</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_C1_6" d="M163.859,131.488L170.109,131.488C176.359,131.488,188.859,131.488,198.234,131.488C207.609,131.488,213.859,131.488,219.443,131.488C225.026,131.488,229.943,131.488,232.401,131.488L234.859,131.488"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C1_C2_7" d="M399.266,131.488L405.516,131.488C411.766,131.488,424.266,131.488,433.641,131.488C443.016,131.488,449.266,131.488,454.849,131.488C460.432,131.488,465.349,131.488,467.807,131.488L470.266,131.488"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C2_C3_8" d="M630.422,131.488L636.672,131.488C642.922,131.488,655.422,131.488,664.797,131.488C674.172,131.488,680.422,131.488,686.005,131.488C691.589,131.488,696.505,131.488,698.964,131.488L701.422,131.488"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C3_C4_9" d="M843.609,131.488L849.859,131.488C856.109,131.488,868.609,131.488,878.026,131.53C887.443,131.572,893.776,131.655,899.443,131.73C905.109,131.804,910.11,131.87,912.61,131.903L915.11,131.936"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C4_C5_10" d="M994.401,115.327L1004.681,109.354C1014.96,103.381,1035.519,91.434,1050.082,85.461C1064.646,79.488,1073.214,79.488,1081.115,79.488C1089.016,79.488,1096.25,79.488,1099.867,79.488L1103.484,79.488"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C4_C6_11" d="M994.401,148.65L1004.681,154.456C1014.96,160.263,1035.519,171.875,1049.592,177.682C1063.664,183.488,1071.25,183.488,1078.169,183.488C1085.089,183.488,1091.341,183.488,1094.467,183.488L1097.594,183.488"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(1056.078125, 79.48828125)" class="edgeLabel"><g transform="translate(-8.015625, -12)" class="label"><foreignObject height="24" width="16.03125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>是</p></span></div></foreignObject></g></g><g transform="translate(1056.078125, 183.48828125)" class="edgeLabel"><g transform="translate(-8.015625, -12)" class="label"><foreignObject height="24" width="16.03125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>否</p></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(104.6796875, 131.48828125)" id="flowchart-C-3611" class="node default"><rect height="54" width="118.359375" y="-27" x="-59.1796875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-29.1796875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="58.359375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>add方法</p></span></div></foreignObject></g></g><g transform="translate(319.0625, 131.48828125)" id="flowchart-C1-3612" class="node default"><rect height="54" width="160.40625" y="-27" x="-80.203125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-50.203125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="100.40625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>计算hashCode</p></span></div></foreignObject></g></g><g transform="translate(552.34375, 131.48828125)" id="flowchart-C2-3614" class="node default"><rect height="54" width="156.15625" y="-27" x="-78.078125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-48.078125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96.15625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>确定存储位置</p></span></div></foreignObject></g></g><g transform="translate(774.515625, 131.48828125)" id="flowchart-C3-3616" class="node default"><rect height="54" width="138.1875" y="-27" x="-69.09375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-39.09375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="78.1875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>equals比较</p></span></div></foreignObject></g></g><g transform="translate(964.5859375, 131.48828125)" id="flowchart-C4-3618" class="node default"><polygon style="fill:#c8e6c9 !important" transform="translate(-45.9765625,45.9765625)" class="label-container" points="45.9765625,0 91.953125,-45.9765625 45.9765625,-91.953125 0,-45.9765625"></polygon><g transform="translate(-18.9765625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="37.953125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>相等?</p></span></div></foreignObject></g></g><g transform="translate(1202.7421875, 79.48828125)" id="flowchart-C5-3620" class="node default"><rect height="54" width="190.515625" y="-27" x="-95.2578125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-65.2578125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="130.515625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>不添加，返回false</p></span></div></foreignObject></g></g><g transform="translate(1202.7421875, 183.48828125)" id="flowchart-C6-3622" class="node default"><rect height="54" width="202.296875" y="-27" x="-101.1484375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-71.1484375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="142.296875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>添加元素，返回true</p></span></div></foreignObject></g></g></g></g><g transform="translate(1383.390625, 0)" class="root"><g class="clusters"><g data-look="classic" id="HashSet实现结构" class="cluster"><rect height="344" width="955.6875" y="8" x="8" style=""></rect><g transform="translate(425.28125, 8)" class="cluster-label"><foreignObject height="24" width="121.125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HashSet实现结构</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_0" d="M162.531,128L168.781,128C175.031,128,187.531,128,196.906,128C206.281,128,212.531,128,218.115,128C223.698,128,228.615,128,231.073,128L233.531,128"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_B1_1" d="M357.09,101L363.903,97.833C370.716,94.667,384.343,88.333,394.281,85.167C404.219,82,410.469,82,416.052,82C421.635,82,426.552,82,429.01,82L431.469,82"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_B2_2" d="M337.174,155L347.306,162.167C357.439,169.333,377.704,183.667,393.627,190.833C409.549,198,421.13,198,432.044,198C442.958,198,453.206,198,458.329,198L463.453,198"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B2_B21_3" d="M569.996,171L587.841,156.167C605.685,141.333,641.374,111.667,662.343,96.833C683.313,82,689.563,82,695.146,82C700.729,82,705.646,82,708.104,82L710.563,82"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B2_B22_4" d="M607.578,191.975L619.159,190.979C630.74,189.983,653.901,187.992,668.607,186.996C683.313,186,689.563,186,695.146,186C700.729,186,705.646,186,708.104,186L710.563,186"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B2_B23_5" d="M578.47,225L594.902,235.833C611.334,246.667,644.198,268.333,663.755,279.167C683.313,290,689.563,290,695.146,290C700.729,290,705.646,290,708.104,290L710.563,290"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(104.015625, 128)" id="flowchart-A-3599" class="node default"><rect height="54" width="117.03125" y="-27" x="-58.515625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-28.515625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="57.03125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HashSet</p></span></div></foreignObject></g></g><g transform="translate(299, 128)" id="flowchart-B-3600" class="node default"><rect height="54" width="122.9375" y="-27" x="-61.46875" data-et="node" data-id="abc" style="fill:#e1f5fe !important" class="basic label-container"></rect><g transform="translate(-31.46875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="62.9375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HashMap</p></span></div></foreignObject></g></g><g transform="translate(537.515625, 82)" id="flowchart-B1-3602" class="node default"><rect height="78" width="204.09375" y="-39" x="-102.046875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-72.046875, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="144.09375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>key: 元素<br>value: PRESENT对象</p></span></div></foreignObject></g></g><g transform="translate(537.515625, 198)" id="flowchart-B2-3604" class="node default"><rect height="54" width="140.125" y="-27" x="-70.0625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-40.0625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="80.125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>哈希表数组</p></span></div></foreignObject></g></g><g transform="translate(820.375, 82)" id="flowchart-B21-3606" class="node default"><rect height="54" width="211.625" y="-27" x="-105.8125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-75.8125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="151.625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>index 0: 链表/红黑树</p></span></div></foreignObject></g></g><g transform="translate(820.375, 186)" id="flowchart-B22-3608" class="node default"><rect height="54" width="211.625" y="-27" x="-105.8125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-75.8125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="151.625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>index 1: 链表/红黑树</p></span></div></foreignObject></g></g><g transform="translate(820.375, 290)" id="flowchart-B23-3610" class="node default"><rect height="54" width="211.625" y="-27" x="-105.8125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-75.8125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="151.625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>index 2: 链表/红黑树</p></span></div></foreignObject></g></g></g></g></g></g></g></svg><p id="z9muka7_13"><span class="control" id="z9muka7_17">HashSet核心实现：</span></p><div class="code-block" data-lang="java">
// HashSet实现原理和去重机制分析
public class HashSetAnalysis {
    
    // 1. HashSet基本操作演示
    public void hashSetBasicDemo() {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        
        System.out.println(&quot;=== HashSet基本操作 ===&quot;);
        System.out.println(&quot;初始大小: &quot; + set.size());
        
        // 添加元素
        System.out.println(&quot;添加'apple': &quot; + set.add(&quot;apple&quot;));
        System.out.println(&quot;添加'banana': &quot; + set.add(&quot;banana&quot;));
        System.out.println(&quot;再次添加'apple': &quot; + set.add(&quot;apple&quot;)); // 返回false
        
        System.out.println(&quot;当前集合: &quot; + set);
        System.out.println(&quot;大小: &quot; + set.size());
        
        // 检查包含
        System.out.println(&quot;包含'apple': &quot; + set.contains(&quot;apple&quot;));
        System.out.println(&quot;包含'orange': &quot; + set.contains(&quot;orange&quot;));
        
        // 删除元素
        System.out.println(&quot;删除'apple': &quot; + set.remove(&quot;apple&quot;));
        System.out.println(&quot;删除后: &quot; + set);
    }
    
    // 2. 去重机制演示
    public void deduplicationDemo() {
        System.out.println(&quot;=== HashSet去重机制演示 ===&quot;);
        
        // 自定义Person类演示
        Set&lt;Person&gt; personSet = new HashSet&lt;&gt;();
        
        Person p1 = new Person(&quot;张三&quot;, 25);
        Person p2 = new Person(&quot;李四&quot;, 30);
        Person p3 = new Person(&quot;张三&quot;, 25); // 与p1相同
        
        personSet.add(p1);
        personSet.add(p2);
        personSet.add(p3);
        
        System.out.println(&quot;添加了3个Person对象，实际大小: &quot; + personSet.size());
        
        for (Person p : personSet) {
            System.out.println(p);
        }
        
        // 演示hashCode和equals的重要性
        System.out.println(&quot;\np1.equals(p3): &quot; + p1.equals(p3));
        System.out.println(&quot;p1.hashCode(): &quot; + p1.hashCode());
        System.out.println(&quot;p3.hashCode(): &quot; + p3.hashCode());
    }
    
    // 自定义Person类（正确实现equals和hashCode）
    static class Person {
        private String name;
        private int age;
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            
            Person person = (Person) obj;
            return age == person.age &amp;&amp; Objects.equals(name, person.name);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }
        
        @Override
        public String toString() {
            return &quot;Person{name='&quot; + name + &quot;', age=&quot; + age + &quot;}&quot;;
        }
        
        // Getters
        public String getName() { return name; }
        public int getAge() { return age; }
    }
    
    // 3. 自定义HashSet实现（简化版）
    public static class SimpleHashSet&lt;E&gt; {
        private SimpleHashMap&lt;E, Object&gt; map;
        private static final Object PRESENT = new Object();
        
        public SimpleHashSet() {
            map = new SimpleHashMap&lt;&gt;();
        }
        
        public boolean add(E e) {
            return map.put(e, PRESENT) == null;
        }
        
        public boolean remove(Object o) {
            return map.remove(o) == PRESENT;
        }
        
        public boolean contains(Object o) {
            return map.containsKey(o);
        }
        
        public int size() {
            return map.size();
        }
        
        public boolean isEmpty() {
            return map.isEmpty();
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(&quot;[&quot;);
            boolean first = true;
            for (E element : map.keySet()) {
                if (!first) sb.append(&quot;, &quot;);
                sb.append(element);
                first = false;
            }
            sb.append(&quot;]&quot;);
            return sb.toString();
        }
    }
    
    // 简化的HashMap实现（支持HashSet）
    static class SimpleHashMap&lt;K, V&gt; {
        private Node&lt;K, V&gt;[] table;
        private int size;
        private static final int DEFAULT_CAPACITY = 16;
        private static final double LOAD_FACTOR = 0.75;
        
        static class Node&lt;K, V&gt; {
            final int hash;
            final K key;
            V value;
            Node&lt;K, V&gt; next;
            
            Node(int hash, K key, V value, Node&lt;K, V&gt; next) {
                this.hash = hash;
                this.key = key;
                this.value = value;
                this.next = next;
            }
        }
        
        public SimpleHashMap() {
            table = new Node[DEFAULT_CAPACITY];
        }
        
        public V put(K key, V value) {
            int hash = hash(key);
            int index = hash &amp; (table.length - 1);
            
            Node&lt;K, V&gt; node = table[index];
            if (node == null) {
                table[index] = new Node&lt;&gt;(hash, key, value, null);
                size++;
                return null;
            }
            
            // 遍历链表
            Node&lt;K, V&gt; prev = null;
            while (node != null) {
                if (node.hash == hash &amp;&amp; Objects.equals(node.key, key)) {
                    V oldValue = node.value;
                    node.value = value;
                    return oldValue;
                }
                prev = node;
                node = node.next;
            }
            
            // 添加新节点
            prev.next = new Node&lt;&gt;(hash, key, value, null);
            size++;
            return null;
        }
        
        public V remove(Object key) {
            int hash = hash(key);
            int index = hash &amp; (table.length - 1);
            
            Node&lt;K, V&gt; node = table[index];
            Node&lt;K, V&gt; prev = null;
            
            while (node != null) {
                if (node.hash == hash &amp;&amp; Objects.equals(node.key, key)) {
                    if (prev == null) {
                        table[index] = node.next;
                    } else {
                        prev.next = node.next;
                    }
                    size--;
                    return node.value;
                }
                prev = node;
                node = node.next;
            }
            
            return null;
        }
        
        public boolean containsKey(Object key) {
            int hash = hash(key);
            int index = hash &amp; (table.length - 1);
            
            Node&lt;K, V&gt; node = table[index];
            while (node != null) {
                if (node.hash == hash &amp;&amp; Objects.equals(node.key, key)) {
                    return true;
                }
                node = node.next;
            }
            return false;
        }
        
        public Set&lt;K&gt; keySet() {
            Set&lt;K&gt; keys = new HashSet&lt;&gt;();
            for (Node&lt;K, V&gt; node : table) {
                while (node != null) {
                    keys.add(node.key);
                    node = node.next;
                }
            }
            return keys;
        }
        
        public int size() { return size; }
        public boolean isEmpty() { return size == 0; }
        
        private int hash(Object key) {
            if (key == null) return 0;
            int h = key.hashCode();
            return h ^ (h &gt;&gt;&gt; 16);
        }
    }
    
    // 4. equals和hashCode的重要性演示
    public void equalsHashCodeDemo() {
        System.out.println(&quot;=== equals和hashCode的重要性 ===&quot;);
        
        // 错误示例：没有重写equals和hashCode
        Set&lt;BadPerson&gt; badSet = new HashSet&lt;&gt;();
        BadPerson bp1 = new BadPerson(&quot;张三&quot;, 25);
        BadPerson bp2 = new BadPerson(&quot;张三&quot;, 25);
        
        badSet.add(bp1);
        badSet.add(bp2);
        
        System.out.println(&quot;BadPerson集合大小: &quot; + badSet.size()); // 2，重复了
        System.out.println(&quot;bp1.equals(bp2): &quot; + bp1.equals(bp2)); // false
        
        // 正确示例：正确重写equals和hashCode
        Set&lt;Person&gt; goodSet = new HashSet&lt;&gt;();
        Person gp1 = new Person(&quot;张三&quot;, 25);
        Person gp2 = new Person(&quot;张三&quot;, 25);
        
        goodSet.add(gp1);
        goodSet.add(gp2);
        
        System.out.println(&quot;Person集合大小: &quot; + goodSet.size()); // 1，去重正确
        System.out.println(&quot;gp1.equals(gp2): &quot; + gp1.equals(gp2)); // true
    }
    
    // 错误的Person类（没有重写equals和hashCode）
    static class BadPerson {
        private String name;
        private int age;
        
        public BadPerson(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public String toString() {
            return &quot;BadPerson{name='&quot; + name + &quot;', age=&quot; + age + &quot;}&quot;;
        }
    }
    
    public static void main(String[] args) {
        HashSetAnalysis analysis = new HashSetAnalysis();
        
        analysis.hashSetBasicDemo();
        System.out.println();
        
        analysis.deduplicationDemo();
        System.out.println();
        
        analysis.equalsHashCodeDemo();
        System.out.println();
        
        // 测试自定义HashSet
        System.out.println(&quot;=== 自定义HashSet测试 ===&quot;);
        SimpleHashSet&lt;String&gt; customSet = new SimpleHashSet&lt;&gt;();
        customSet.add(&quot;A&quot;);
        customSet.add(&quot;B&quot;);
        customSet.add(&quot;A&quot;); // 重复元素
        System.out.println(&quot;自定义HashSet: &quot; + customSet);
        System.out.println(&quot;大小: &quot; + customSet.size());
    }
}
</div></section><section class="chapter"><h3 id="q2-treeset-linkedhashset-hashset" data-toc="q2-treeset-linkedhashset-hashset">Q2: TreeSet和LinkedHashSet有什么特点？与HashSet有什么区别？</h3><p id="z9muka7_18"><span class="control" id="z9muka7_23">答案：</span></p><p id="z9muka7_19"><span class="control" id="z9muka7_24">三种Set实现对比：</span></p><p id="z9muka7_21"><span class="control" id="z9muka7_25">三种Set的详细实现：</span></p><div class="code-block" data-lang="java">
// TreeSet和LinkedHashSet详解
public class SetComparison {
    
    // 1. TreeSet演示
    public void treeSetDemo() {
        System.out.println(&quot;=== TreeSet演示 ===&quot;);
        
        // 自然排序
        TreeSet&lt;Integer&gt; numberSet = new TreeSet&lt;&gt;();
        numberSet.add(5);
        numberSet.add(2);
        numberSet.add(8);
        numberSet.add(1);
        numberSet.add(9);
        
        System.out.println(&quot;TreeSet（自然排序）: &quot; + numberSet);
        // 输出: [1, 2, 5, 8, 9]
        
        // 自定义排序
        TreeSet&lt;String&gt; stringSet = new TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);
        stringSet.add(&quot;banana&quot;);
        stringSet.add(&quot;Apple&quot;);
        stringSet.add(&quot;cherry&quot;);
        stringSet.add(&quot;date&quot;);
        
        System.out.println(&quot;TreeSet（忽略大小写排序）: &quot; + stringSet);
        // 输出: [Apple, banana, cherry, date]
        
        // TreeSet的导航方法
        System.out.println(&quot;第一个元素: &quot; + numberSet.first());
        System.out.println(&quot;最后一个元素: &quot; + numberSet.last());
        System.out.println(&quot;小于5的最大元素: &quot; + numberSet.lower(5));
        System.out.println(&quot;大于等于5的最小元素: &quot; + numberSet.ceiling(5));
        System.out.println(&quot;子集[2,8): &quot; + numberSet.subSet(2, 8));
    }
    
    // 2. LinkedHashSet演示
    public void linkedHashSetDemo() {
        System.out.println(&quot;=== LinkedHashSet演示 ===&quot;);
        
        LinkedHashSet&lt;String&gt; linkedSet = new LinkedHashSet&lt;&gt;();
        linkedSet.add(&quot;first&quot;);
        linkedSet.add(&quot;second&quot;);
        linkedSet.add(&quot;third&quot;);
        linkedSet.add(&quot;first&quot;); // 重复元素，不会添加
        
        System.out.println(&quot;LinkedHashSet（保持插入顺序）: &quot; + linkedSet);
        // 输出: [first, second, third]
        
        // 对比HashSet的无序性
        HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();
        hashSet.add(&quot;first&quot;);
        hashSet.add(&quot;second&quot;);
        hashSet.add(&quot;third&quot;);
        
        System.out.println(&quot;HashSet（无序）: &quot; + hashSet);
        // 输出顺序可能不同
    }
    
    // 3. 性能对比测试
    public void performanceComparison() {
        final int SIZE = 100000;
        
        System.out.println(&quot;=== Set性能对比（数据量: &quot; + SIZE + &quot;）===&quot;);
        
        // 测试添加性能
        long startTime = System.nanoTime();
        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; SIZE; i++) {
            hashSet.add(i);
        }
        long hashSetAddTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        Set&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();
        for (int i = 0; i &lt; SIZE; i++) {
            treeSet.add(i);
        }
        long treeSetAddTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        Set&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
        for (int i = 0; i &lt; SIZE; i++) {
            linkedHashSet.add(i);
        }
        long linkedHashSetAddTime = System.nanoTime() - startTime;
        
        System.out.println(&quot;添加性能:&quot;);
        System.out.println(&quot;  HashSet: &quot; + hashSetAddTime / 1_000_000 + &quot;ms&quot;);
        System.out.println(&quot;  TreeSet: &quot; + treeSetAddTime / 1_000_000 + &quot;ms&quot;);
        System.out.println(&quot;  LinkedHashSet: &quot; + linkedHashSetAddTime / 1_000_000 + &quot;ms&quot;);
        
        // 测试查找性能
        Random random = new Random();
        startTime = System.nanoTime();
        for (int i = 0; i &lt; 10000; i++) {
            hashSet.contains(random.nextInt(SIZE));
        }
        long hashSetContainsTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i &lt; 10000; i++) {
            treeSet.contains(random.nextInt(SIZE));
        }
        long treeSetContainsTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        for (int i = 0; i &lt; 10000; i++) {
            linkedHashSet.contains(random.nextInt(SIZE));
        }
        long linkedHashSetContainsTime = System.nanoTime() - startTime;
        
        System.out.println(&quot;查找性能(10000次):&quot;);
        System.out.println(&quot;  HashSet: &quot; + hashSetContainsTime / 1_000_000 + &quot;ms&quot;);
        System.out.println(&quot;  TreeSet: &quot; + treeSetContainsTime / 1_000_000 + &quot;ms&quot;);
        System.out.println(&quot;  LinkedHashSet: &quot; + linkedHashSetContainsTime / 1_000_000 + &quot;ms&quot;);
    }
    
    // 4. 自定义对象在不同Set中的表现
    public void customObjectDemo() {
        System.out.println(&quot;=== 自定义对象在不同Set中的表现 ===&quot;);
        
        // Student类需要实现Comparable才能用于TreeSet
        Set&lt;Student&gt; hashSetStudents = new HashSet&lt;&gt;();
        Set&lt;Student&gt; treeSetStudents = new TreeSet&lt;&gt;();
        Set&lt;Student&gt; linkedHashSetStudents = new LinkedHashSet&lt;&gt;();
        
        Student s1 = new Student(&quot;Alice&quot;, 85);
        Student s2 = new Student(&quot;Bob&quot;, 92);
        Student s3 = new Student(&quot;Charlie&quot;, 78);
        Student s4 = new Student(&quot;Alice&quot;, 85); // 重复
        
        // 添加到各个Set
        hashSetStudents.add(s1);
        hashSetStudents.add(s2);
        hashSetStudents.add(s3);
        hashSetStudents.add(s4);
        
        treeSetStudents.add(s1);
        treeSetStudents.add(s2);
        treeSetStudents.add(s3);
        treeSetStudents.add(s4);
        
        linkedHashSetStudents.add(s1);
        linkedHashSetStudents.add(s2);
        linkedHashSetStudents.add(s3);
        linkedHashSetStudents.add(s4);
        
        System.out.println(&quot;HashSet结果（无序，去重）:&quot;);
        hashSetStudents.forEach(System.out::println);
        
        System.out.println(&quot;\nTreeSet结果（按分数排序，去重）:&quot;);
        treeSetStudents.forEach(System.out::println);
        
        System.out.println(&quot;\nLinkedHashSet结果（插入顺序，去重）:&quot;);
        linkedHashSetStudents.forEach(System.out::println);
    }
    
    // Student类，实现Comparable接口
    static class Student implements Comparable&lt;Student&gt; {
        private String name;
        private int score;
        
        public Student(String name, int score) {
            this.name = name;
            this.score = score;
        }
        
        @Override
        public int compareTo(Student other) {
            // 按分数排序，分数高的在前
            int scoreCompare = Integer.compare(other.score, this.score);
            if (scoreCompare != 0) {
                return scoreCompare;
            }
            // 分数相同时按姓名排序
            return this.name.compareTo(other.name);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            
            Student student = (Student) obj;
            return score == student.score &amp;&amp; Objects.equals(name, student.name);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name, score);
        }
        
        @Override
        public String toString() {
            return &quot;Student{name='&quot; + name + &quot;', score=&quot; + score + &quot;}&quot;;
        }
    }
    
    // 5. 使用场景总结
    public void usageScenarios() {
        System.out.println(&quot;=== Set使用场景总结 ===&quot;);
        
        System.out.println(&quot;HashSet适用场景:&quot;);
        System.out.println(&quot;1. 需要快速去重，不关心元素顺序&quot;);
        System.out.println(&quot;2. 频繁进行添加、删除、查找操作&quot;);
        System.out.println(&quot;3. 数据量大，性能要求高&quot;);
        System.out.println(&quot;4. 缓存、索引等场景&quot;);
        
        System.out.println(&quot;\nTreeSet适用场景:&quot;);
        System.out.println(&quot;1. 需要有序的去重集合&quot;);
        System.out.println(&quot;2. 需要范围查询（如查找某个区间的元素）&quot;);
        System.out.println(&quot;3. 需要最大值、最小值等边界操作&quot;);
        System.out.println(&quot;4. 排行榜、有序统计等场景&quot;);
        
        System.out.println(&quot;\nLinkedHashSet适用场景:&quot;);
        System.out.println(&quot;1. 需要去重且保持插入顺序&quot;);
        System.out.println(&quot;2. 需要可预测的迭代顺序&quot;);
        System.out.println(&quot;3. LRU缓存的实现&quot;);
        System.out.println(&quot;4. 保持处理顺序的业务场景&quot;);
    }
    
    public static void main(String[] args) {
        SetComparison comparison = new SetComparison();
        
        comparison.treeSetDemo();
        System.out.println();
        
        comparison.linkedHashSetDemo();
        System.out.println();
        
        comparison.performanceComparison();
        System.out.println();
        
        comparison.customObjectDemo();
        System.out.println();
        
        comparison.usageScenarios();
    }
}
</div></section></section><section class="chapter"><h2 id="z9muka7_6" data-toc="z9muka7_6">💡 面试技巧</h2><section class="chapter"><h3 id="z9muka7_26" data-toc="z9muka7_26">高频考点</h3><ol class="list _decimal" id="z9muka7_28" type="1"><li class="list__item" id="z9muka7_29"><p id="z9muka7_34"><span class="control" id="z9muka7_35">去重原理</span> ：equals和hashCode的重要性、对象相等性判断</p></li><li class="list__item" id="z9muka7_30"><p id="z9muka7_36"><span class="control" id="z9muka7_37">底层实现</span> ：HashSet基于HashMap、TreeSet基于TreeMap、LinkedHashSet的双重结构</p></li><li class="list__item" id="z9muka7_31"><p id="z9muka7_38"><span class="control" id="z9muka7_39">性能特点</span> ：各种Set的时间复杂度和适用场景对比</p></li><li class="list__item" id="z9muka7_32"><p id="z9muka7_40"><span class="control" id="z9muka7_41">有序性</span> ：TreeSet的自然排序、LinkedHashSet的插入顺序</p></li><li class="list__item" id="z9muka7_33"><p id="z9muka7_42"><span class="control" id="z9muka7_43">null值处理</span> ：HashSet和LinkedHashSet允许null、TreeSet不允许</p></li></ol></section><section class="chapter"><h3 id="z9muka7_27" data-toc="z9muka7_27">回答策略</h3><ol class="list _decimal" id="z9muka7_44" type="1"><li class="list__item" id="z9muka7_47"><p id="z9muka7_51"><span class="control" id="z9muka7_52">原理清晰</span> ：能够解释Set的去重机制和底层数据结构</p></li><li class="list__item" id="z9muka7_48"><p id="z9muka7_53"><span class="control" id="z9muka7_54">对比分析</span> ：熟悉三种Set实现的优缺点和使用场景</p></li><li class="list__item" id="z9muka7_49"><p id="z9muka7_55"><span class="control" id="z9muka7_56">代码示例</span> ：能够正确实现equals和hashCode方法</p></li><li class="list__item" id="z9muka7_50"><p id="z9muka7_57"><span class="control" id="z9muka7_58">实际应用</span> ：结合具体业务场景选择合适的Set实现</p></li></ol><p id="z9muka7_46"><span class="control" id="z9muka7_59">学习建议</span> ：Set的核心是去重机制，重点理解equals和hashCode的作用。通过实际编程验证不同Set实现的特性，加深对有序性和性能的理解。</p></section></section><div class="last-modified">09 六月 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="list集合详解qa.html" class="navigation-links__prev">List集合详解QA</a><a href="map集合详解qa.html" class="navigation-links__next">Map集合详解QA</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>